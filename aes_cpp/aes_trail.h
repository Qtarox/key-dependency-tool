#include "aes.h"
#include <iostream>
#include <iomanip>
#include <random>
#include <string>

using namespace std;

static mt19937 rand_generator;

static void conversion(uint8_t alpha[20][4][4],uint32_t trail_rounds,uint8_t key_diff[3][4][4])
{
	uint8_t key_diff_temp[3][4][4];
	for (int i = 0; i < 3; i++){ for (int j = 0; j < 4; j++) { for (int k = 0; k < 4; k++) key_diff_temp[i][j][k] = key_diff[i][j][k];}}
	for (int i = 0; i < trail_rounds-1; i++){ keyScheduleRoundFunction(key_diff_temp);}
	SR(alpha[trail_rounds]);
	MC(alpha[trail_rounds]);
}

static bool sanityCheckFixedKey(uint8_t alpha[20][4][4],uint32_t trail_rounds,uint8_t fixedKey[20][4][4])
{
	uint32_t DDT[256][256] = {0};
	computeDDT(DDT);

	uint8_t state_temp_before[4][4];
	uint8_t state_temp_after[4][4];
	for (int n = 0; n < trail_rounds; n++)
	{
		for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++){ state_temp_before[r][c] = alpha[n][r][c]; }}
		for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++){ state_temp_after[r][c] = alpha[n+1][r][c]; }}
		for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++){ state_temp_after[r][c] ^= fixedKey[n][r][c]; }}
		invMC(state_temp_after); invSR(state_temp_after); 
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++)
			{
				std::cout << std::setw(2) << std::hex << int(state_temp_before[r][c]) << " ";
			}
			std::cout << "  ";
			for (int c = 0; c < 4; c++)
			{
				std::cout << std::setw(2) << std::hex << int(state_temp_after[r][c]) << " ";
			}
			std::cout << "  ";
			for (int c = 0; c < 4; c++)
			{
				std::cout << std::setw(2) << std::hex << int(fixedKey[n][r][c]) << " ";
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++) 
			{
				if (DDT[state_temp_before[r][c]][state_temp_after[r][c]] == 0) 
				{
					std::cout << "Error in round: " << n << ", pos: " << 4*r+c << ", input: " << int(state_temp_before[r][c]) << ", output: " << int(state_temp_after[r][c]) << std::endl;
					return false;
				}
			}
		}
	}
	return true;
}

void generateBestTrail(uint8_t alpha[20][4][4], uint8_t actualKeyDiff[20][4][4], uint8_t a, uint8_t pos, uint32_t &trail_rounds, int &TK_NUM)
{
	TK_NUM = 1;
	trail_rounds = 4;
	uniform_int_distribution<uint8_t> rng8(0, 0xff);
	uint32_t DDT[256][256] = {0};
	computeDDT(DDT);
	uint8_t rand_num;
	// a is the value of the active byte at the end of the second round
	// pos is the position of the active cell (0 - 15)
	uint8_t tmp[4][4] = {0}; tmp[pos/4][pos%4] = a;
	for (int r = 0; r < 4; r++)
	{
		for (int c = 0; c < 4; c++) alpha[2][r][c] = tmp[r][c];
	}
	// backwards
	for (int n = 1; n >= 0; n--)
	{
		invMC(tmp);
		invSR(tmp);
		// invSubstitution (random for now?)
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++)
			{
				if (tmp[r][c] != 0)
				{
					while (true)
					{
						rand_num = rng8(rand_generator);
						if (DDT[rand_num][tmp[r][c]] != 0)
						{
							tmp[r][c] = rand_num;
							break;
						}
					}
				}
			}
		}
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++) alpha[n][r][c] = tmp[r][c];
		}
	}
	// forward 

	for (int r = 0; r < 4; r++)
	{
		for (int c = 0; c < 4; c++) tmp[r][c] = alpha[2][r][c];
	}
	for (int n = 3; n < 5; n++)
	{
		// Substitution
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++)
			{
				if (tmp[r][c] != 0)
				{
					while (true)
					{
						rand_num = rng8(rand_generator);
						if (DDT[tmp[r][c]][rand_num] != 0)
						{
							tmp[r][c] = rand_num;
							break;
						}
					}
				}
			}
		}
		// SR & MC
		SR(tmp);
		MC(tmp);
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++) alpha[n][r][c] = tmp[r][c];
		}
	}
	
	if (!sanityCheckFixedKey(alpha,trail_rounds,actualKeyDiff))
	{
		std::cout << "Insanity!" << std::endl;
		exit(0);
	}
	
}

void TK1_2009_241(uint8_t alpha[20][4][4], uint8_t actualKeyDiff[20][4][4], uint32_t& trail_rounds, int &TK_NUM)
{
	trail_rounds = 14;
	TK_NUM = 1;
	uint8_t alpha_before_temp[20][4][4] = {\
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x0f,0x0e,0x0f,0x0e},{0x07,0x07,0x07,0x07},{0x07,0x07,0x07,0x07},{0x09,0x09,0x09,0x09}},
	 {{0x52,0x00,0x35,0x00},{0x00,0x25,0x00,0x00},{0x00,0x00,0xfd,0x00},{0x00,0x00,0x00,0x33}},
	 {{0x03,0x01,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x09,0x09,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x09,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x01,0x01,0x01},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x00,0x01,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x01,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x01,0x01,0x01,0x01},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	 {{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}}};

	uint8_t actualKey_temp[20][4][4] = {\
	{{0x0f,0x0e,0x0f,0x0e},{0x07,0x07,0x07,0x07},{0x07,0x07,0x07,0x07},{0x09,0x09,0x09,0x09}},
	{{0x37,0x00,0x37,0x00},{0x1f,0x00,0x1f,0x00},{0x1f,0x00,0x1f,0x00},{0x21,0x00,0x21,0x00}},
	{{0x0f,0x01,0x0e,0x00},{0x07,0x00,0x07,0x00},{0x07,0x00,0x07,0x00},{0x09,0x00,0x09,0x00}},
	{{0x37,0x37,0x00,0x00},{0x1f,0x1f,0x00,0x00},{0x1f,0x1f,0x00,0x00},{0x21,0x21,0x00,0x00}},
	{{0x0f,0x0e,0x00,0x00},{0x07,0x07,0x00,0x00},{0x07,0x07,0x00,0x00},{0x09,0x09,0x00,0x00}},
	{{0x37,0x00,0x00,0x00},{0x1f,0x00,0x00,0x00},{0x1f,0x00,0x00,0x00},{0x21,0x00,0x00,0x00}},
	{{0x0f,0x01,0x01,0x01},{0x07,0x00,0x00,0x00},{0x07,0x00,0x00,0x00},{0x09,0x00,0x00,0x00}},
	{{0x3e,0x3e,0x3e,0x3e},{0x1f,0x1f,0x1f,0x1f},{0x1f,0x1f,0x1f,0x1f},{0x21,0x21,0x21,0x21}},
	{{0x01,0x00,0x01,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x3e,0x00,0x3e,0x00},{0x1f,0x00,0x1f,0x00},{0x1f,0x00,0x1f,0x00},{0x21,0x00,0x21,0x00}},
	{{0x01,0x01,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x3e,0x3e,0x00,0x00},{0x1f,0x1f,0x00,0x00},{0x1f,0x1f,0x00,0x00},{0x21,0x21,0x00,0x00}},
	{{0x01,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x3e,0x00,0x00,0x00},{0x1f,0x00,0x00,0x00},{0x1f,0x00,0x00,0x00},{0x21,0x00,0x00,0x00}},
	{{0x01,0x01,0x01,0x01},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}},
	{{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00}}};
	for (int r = 0; r < 20; r++) {for (int i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) {alpha[r][i][j] = alpha_before_temp[r][i][j];}}}
	for (int r = 0; r < 20; r++) {for (int i = 0; i < 4; i++) { for (int j = 0; j < 4; j++) {actualKeyDiff[r][i][j] = actualKey_temp[r][i][j];}}}
	if (!sanityCheckFixedKey(alpha,trail_rounds,actualKeyDiff))
	{
		std::cout << "Insanity!" << std::endl;
		exit(0);
	}
}

void justACrazyTrail(uint8_t alpha[20][4][4], uint8_t actualKeyDiff[20][4][4], uint32_t& trail_rounds, int &TK_NUM)
{
	uint8_t rand_num;
	uniform_int_distribution<uint8_t> rng8(0, 0xff);
	uint8_t tmp[4][4] = {0};
	uint32_t DDT[256][256] = {0};
	computeDDT(DDT);
	
	for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++) tmp[r][c] = rng8(rand_generator);}
	for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++) alpha[0][r][c] = tmp[r][c];}
	for (int n = 0; n < 10; n++)
	{
		// forward
		// Substitution
		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++)
			{
				if (tmp[r][c] != 0)
				{
					while (true)
					{
						rand_num = rng8(rand_generator);
						if (DDT[tmp[r][c]][rand_num] != 0)
						{
							tmp[r][c] = rand_num;
							break;
						}
					}
				}
			}
		}
		SR(tmp);
		MC(tmp);
		for (int r = 0; r < 4; r++){ for (int c = 0; c < 4; c++) alpha[n+1][r][c] = tmp[r][c]; }
	}
	trail_rounds = 7;
	TK_NUM = 1;
	if (!sanityCheckFixedKey(alpha,trail_rounds,actualKeyDiff))
	{
		std::cout << "Insanity!" << std::endl;
		exit(0);
	}
}